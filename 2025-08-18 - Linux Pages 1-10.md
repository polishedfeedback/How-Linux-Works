# üìÖ Date: 2025-08-24
## üìñ Pages Covered
From page: 1  To page: 10

---

## üìù Key Points (in my own words)
-  **Abstraction** - Focus on what a component while ignoring the low-level details
-  **Components** - Subsystems / modules / packages that make up Linux
- A Linux system can be divided into three main levels: Hardware, Kernel, and Processes
- Hardware resides at the bottom and includes Memory, Network Interface, CPU, Disks etc.
- Kernel lives in between Hardware and the user space and is the core of the OS. The main job of the kernel is to manage tasks and tell the CPU what it's next task is.
- User processes are the applications that a user can see or run. For example, GUI, Servers, Shell
- A Kernel runs the processes in Kernel mode. Kernel mode has unrestricted access to processor and memory and can crash the entire system.
- User processes run in user mode. User mode has a restricted access to memory
- The memory area only kernel can access is called kernel space. 
- User space means the parts of main memory that the user processes can access.
- Kernel also runs threads that look like processes but have access to Kernel space. For example kthread, kblockd
- Main memory is the most important hardware on a computer system.
- It contains 0s and 1s. Each slot of 0 or 1 is called a bit. 
- The input and output from the peripheral devices flow through the memory
- CPU is just an operator on the memory. It runs the instructions and writes the data back to the memory. 
- A state is an arrangement of bits. For example if you have 4 bits in the memory, 0010, 0100, 1000 represent three different states.
- Image refers to a particular physical arrangement of bits.
- One of the most important kernel's job is to split the memory into many subdivisions and maintain the state of these subdivisions. It should also ensure that each process keeps to its own share of memory
- Kernel is in charge of managing tasks in these four general areas
	- Process Management
	- Memory Management
	- Device Drivers
	- System calls

## Process Management
- Process Management involves in starting, pausing, resuming, scheduling and terminating the process. 
- Only one process can run on a CPU core at a time, even if it looks like many are running
- OS uses time slices, each process runs briefly, then yields to the next.
- Multitasking means rapid context switching, so human perceive tasks as simulataneous.

### Context Switching
- CPU Interrupts the running process after it's time slice and hands the control to kernel who's job is to 
	- Switches to kernel mode and saves the process state
	- Finish the tasks that might have come in the preceding time slice
	- Choose a process from the running processes in the queue
	- Prepares memory & CPU for the new process
	- Defines the time slice length for the next process to finish the computation
	- Hands CPU to the next process and switches to user mode
- This process of switching between one process to another process is called context-switching
### Multi-core difference
- Multiple processes can run at the same time
- Kernel still manages context switches to maximize CPU usage

## Memory Management
- Kernel must manage the memory with the following conditions
	- Kernel must have it's own memory that the processes cannot access
	- Each user process needs its own share of the memory
	- One user process may not access the private memory of another process
	- User processes can share memory
	- Some memory in the user processes can be read-only
	- The system can use more memory than is physically present by using disk space as **_auxiliary_** 
### Memory Management Unit (MMU)
-  Modern computers come with Memory Management Unit
- Job of MMU is to create a virtual memory where each process assumes that it owns the entire machine to itself
- This virtual machine is translated by actual physical memory on the machine by MMU which is called **_Memory address Mapping_**
- Kernel must maintain the Memory Address Map
- During context switching kernel swaps the memory map from the old process to a new process

## Device Drivers and Management
- Device drivers must run in Kernel mode to prevent improper access that leads to crashing of a machine
- Devices rarely have the same programming interface
- So device drivers are there to put an uniform interface between the devices

## System Calls and Support
- Almost every user process uses system calls to talk to the kernel
	- Examples of these are opening, writing and reading files
- Important system calls for processes:
	- `fork()` - Creates a nearly identical copy of the process
	- `exec(program)` - replaces the current process with `program` 
	- Other than init all the processes in Linux start as a result of `fork()`
- What happens when you run ls
    - Shell calls `fork()` to create a copy of itself
    - This copy of shell runs `exec(ls)` to execute ls
- **Psuedo Devices**
    - Psuedo devices are basically fake devices that look like hardware but are purely implemented in the software
    - These often need privileged operations and run in kernel mode rather than user mode
    - Example /dev/random is a random number generator for kernel, and is difficult to run in user mode. This looks like a hardware device but it is purely implemented in the software 
    - For a user process to use /dev/random, they have to make system calls (open, read, write)

## User Space
- The main memory that Kernel creates for the user processes is called user space
- Processes are equal from Kernel's perspective but differ in function for the user
- Service layers (rough structure, there are no strict rules):
	- Bottom layer - Small, simple services (logging, communication bus, network config)
	- Middle Layer - Larger services (mail, print, databases)
	- Top Layer - This is the layer that has the services that user can touch

## Users
- The user is an entity that can run the processes and files of their own
- Every user is associated with a username and are identified by that and each user process is run by a user **_owner_**
- Kernel does not recognise a user by their username but it rather identifies them by their userid 
- Users exist primarily to support permissions and boundaries
- A user may terminate or modify the behaviour of their own processes but should not interfere with the other user's processes
- The above rules does not apply to a user called **_root_** . 
- Root is a special user in linux who has access to all the local file system and can do anything without any restrictions. For this reason, a root user is also called a superuser
- A user who has the root access is called an administrator.
- Groups are sets of users. The main purpose of the groups is to share the files or access to other users / members in the group.
- Operating as root user can be dangerous and has to be avoided whenever possible.
    
---

## ‚ùì Flashcards
‚ùì Flashcards

START
Basic
Front: What term is commonly used for subdivisions of software in Linux? 
Back: Components (also called subsystems, modules, or packages) Tags: components, subdivision, linux 
<!--ID: 1756073189747-->
END

START
Basic
Front: How many levels does a Linux system has and what are they? Back: Three levels. From Bottom - Hardware, Kernel, User Processes 
<!--ID: 1756073189754-->
END

START
Basic
Front: What is the main job of kernel?
Back: The main job of the kernel is to allocate tasks to CPU
<!--ID: 1756073189759-->
END

START
Basic
Front: What does a Hardware layer consist of? 
Back: Hardware mostly consists of one or more CPU s, Memory, Disks, Network Interface. 
<!--ID: 1756073189764-->
END

START
Basic
Front: What does a kernel consist of or do?
Back: System calls, Process Management, Memory Management, Device Drivers. END

START
Basic
Front: What does a user processes or processes consist of?
Back: Applications, server, GUI.
<!--ID: 1756073189768-->
END

START
Basic
Front: Kernel runs the processes in what mode? Back: Kernel mode
<!--ID: 1756073189773-->
END

START
Basic
Front: User runs the processes in what mode? Back: User mode
<!--ID: 1756073189778-->
END

START
Basic
Front: Memory to which kernel has access to is called? Back: Kernel space
<!--ID: 1756073189782-->
END

START Basic Front: What is the problem of running processes in kernel mode? Back: Processes in kernel mode has unrestricted access and can wreak havoc. END

START Basic Front: Provide two examples of kernel threads that look like processes? Back: kthread, kblockd END

START Basic Front: What does the term state mean Back: State means particular arrangement of bits. State can also be referred to what the process is doing at the particular moment. For example, waiting for the input etc. END

START
Basic
Front: What does the term image mean Back: Image refers to a particular physical arrangement of bits.
<!--ID: 1756073189788-->
END

START
Basic
Front: Kernel is in charge of managing tasks in four general areas, what are they? Back: Process management, Memory Management, Device Drivers, System Calls END

START
Basic
Front: What is the act of one process giving CPU control to another process called? Back: Context Switching
<!--ID: 1756073189795-->
END

START
Basic
Front: The time in which one process runs before handing the control to another process is called? Back: Time slice
<!--ID: 1756073189802-->
END

START
Basic
Front: What are kernel's main requirements for memory management? 
Back:

1. Private Kernel Memory
2. Each process has it's own memory
3. No cross-access between processes
4. Processes can share the memory
5. Some memory can be read-only
6. Use disk space as an extra space (swap)
<!--ID: 1756073189819-->
END

START
Basic
Front: What hardware feature enables virtual memory?
Back: Memory Management Unit (MMU)
<!--ID: 1756073189824-->
END

START
Basic
Front: What is a virtual memory? 
Back: A memory scheme where each process acts as if it has its own machine
<!--ID: 1756073189831-->
END

START
Basic
Front: What role does kernel play in virtual memory?
Back: It maintains the memory address map, switching it between the processes during the context switch
<!--ID: 1756073189835-->
END

START
Basic
Front: Why is virtual memory important?
Back: It separates the processes, allows flexible memory use (including sharing and read-only regions), and enables more memory than physically installed via swap
<!--ID: 1756073189842-->
END

START
Basic
Front: What is the implementation of memory address map called?
Back: Page table
<!--ID: 1756073189847-->
END

START
Basic
Front: Why are devices usually only accessible in kernel mode?
Back: To prevent improper access (e.g., user process shutting down power)
<!--ID: 1756073189880-->
END

START
Basic
Front: How does kernel solve the problem of device differences?
Back: By using device drivers that provide a uniform interface to user processes
<!--ID: 1756073189887-->
END

START
Basic
Front: What are system calls (syscalls) in Linux?
Back: User processes sometimes need to use kernel services that they cannot do on their own (e.g., Opening a file, reading, writing)
<!--ID: 1756073189896-->
END

START
Basic
Front: What does fork() do in Linux?
Back: Creates a nearly identical copy of the current process
<!--ID: 1756073189900-->
END

START
Basic
Front: What does exec(program) do in Linux?
Back: Replaces the current process with the specified program
<!--ID: 1756073189903-->
END

START
Basic
Front: How do most of the new processes start in Linux?
Back: With fork() to create a copy, then exec() to replace it with a new program
<!--ID: 1756073189906-->
END

START
Basic
Front: What happens when you type `ls` in a shell? 
Back: The shell calls fork() to create it's own copy and then the copy runs exec(ls) to execute ls 
<!--ID: 1756073189911-->
END

START
Basic
Front: What are pseudodevices in Linux?
Back: Interfaces that look like devices but are purely implemented in the software (e.g., /dev/random)
<!--ID: 1756073189915-->
END

START
Basic
Front: Why does accessing a pseudodevice still require a system call?
Back: Because processes must use syscalls (like open) to interact with them.
<!--ID: 1756073189918-->
END

START
Basic
Front: What is the userspace (userland) in Linux
Back: The space in main memory where all the user processes reside is called Userspace. This is the space that kernel reserves for them.
<!--ID: 1756073189922-->
END

START
Basic
Front: How are the user-processes roughly structured in service layers?
Back: - Bottom: small / simple services (logging, network config)

- Middle: larger services (mail, print, databases)
- Top: services that user can touch (browsers, UI) 
<!--ID: 1756073189926-->
END

START
Basic
Front: Are user-space services strictly structured?
Back: No, they are not. It's only an approximation and many components can fit into the multiple levels depending on the use.
<!--ID: 1756073189974-->
END

START
Basic
Front: Who are users in Linux
Back: A user is an entity who can either terminate or modify the behaviour of their own processes
<!--ID: 1756073189981-->
END

START
Basic
Front: How are users identified in Linux or what are they usually associated with Back: Users in Linux are associated with usernames
<!--ID: 1756073189988-->
END

START
Basic
Front: How does Kernel identify a user
Back: Kernel identifies a user by their userids and not usernames
<!--ID: 1756073189997-->
END

START
Basic
Front: Who is called the superuser in Linux
Back: Root is called superuser in Linux because root account has no restrictions and has access to the entire local system
<!--ID: 1756073190001-->
END

START
Basic
Front: Who is called an administrator in Linux
Back: A user with root access is called an administrator
<!--ID: 1756073190005-->
END

START
Basic
Front: What are groups in Linux and why are they used
Back: Groups are set of users and are used to share files / access among the other members in the group.
<!--ID: 1756073190008-->
END

---

## üîÑ Review Log
- [ ] Day 2: {{date+1d}}
- [ ] Day 4: {{date+3d}}
- [ ] Day 8: {{date+7d}}
- [ ] Day 15: {{date+14d}}
