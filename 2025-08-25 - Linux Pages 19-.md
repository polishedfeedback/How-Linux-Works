# üìÖ Date: 2025-08-25
## üìñ Pages Covered
From page: 19 To page: ___

---

## üìù Key Points (in my own words)
## Intermediate commands
### `grep`
**Purpose**: `grep` prints the lines from a file or an input stream that exactly matches the given expression. 
**Syntax**:
```
grep root /etc/passwd
```
**Additional Flags / Arguments**:
- `grep` is extremely handy when you want to find the words from multiple files. It gives the file name along with the matched words while printing the output. For example
```
grep root /etc/*
```
- To tell `grep` that you want a case-insensitive search, you use the option `-i`.
- To tell `grep` that you want to find the words that do not match (inverse / invert search), you use the option -v
- `grep` also supports regular expressions. There is also an alternate grep version called `egrep` which is just a synonym for `grep -e`
- Three most important regular expressions to remember
	- `.*` matches any number of characters, including none 
	- `.+` matches one or more characters
	- `.` matches exactly one arbitrary character

### `less`
**Purpose**: `less` is a pager and is useful when the file is too big and you want to only read one screenful at a time.
**Syntax**: 
```
less /usr/share/dict/words
```
**Additional Flags / Arguments**:
- Press the spacebar to go forward the file while in less
- Press q to quit
- Press lowercase b to go back one screenful
- Press /word to search inside less
- Press ?word to search backwards

### `pwd`
**Purpose**: `pwd` is used to print the current working directory 
**Syntax**: 
```
pwd
```
**Additional Flags / Arguments: 
- Symlinks are basically shortcuts or pointers to another file or directory
- When you `cd` into a symlink, the shell remembers the path you typed, but not the actual directory
- In this case, use `pwd -P` to eliminate the confusion and let the shell give you the actual original path rather than the symlink path.

### `diff`
**Purpose**: `diff` is used to find differences between files
**Syntax**:
```
diff file1 file2
```
**Additional Flags / Arguments**: 
- Most of the times `diff` is sufficient to find the differences, but for more human readable format, use `diff -u file1 file2`
- `diff` only shows which line the difference occurs rather than focusing on the word itself but `diff -u` focuses on the word, rather than letting you know the line etc.
- If you're familiar with `git diff`, it uses `diff -u` under the hood.

### `file`
**Purpose**: `file` command lets you view the format of the file.
**Syntax**: 
```
file file
```
### `find` and `locate`
**Purpose**: `find` and `locate` are used to find the files from either the current directory or a directory specified
**Syntax**: 
```
find dir -name file -print
```
- The above command is used to find a file named file in a specified directory dir
**Additional Flags / Arguments**:
- Unlike `find` which finds the file on the go, `locate` finds the files based on its previous index.
- `locate` is faster than `find` because it searches from the index but if the file is not available in the index yet, `locate` will not find the file
- `locate` might not be available on all the distributions and can be installed using package managers searching for *plocate*. The index of locate can be updated using `updatedb` command.

### `head` and `tail`
**Purpose**: The head and tail commands allow you to quickly view a portion of a file or a stream of data. `head` shows the first 10 lines by default and `tail` shows the last 10 lines by default. 
**Syntax**: 
```
head /etc/passwd
tail /etc/passwd
```
**Additional Flags / Arguments / Notes**:
- The default option of number of lines can be changed by using the `-n` flag. For example, to only view the first 5 lines from the beginning of a file, you can use omit specifying `-n` in the command and use `head -5 /etc/passwd`
- In the same way, to only view the last 5 lines from the file, `tail -5 /etc/passwd`
- You can also print lines starting at a specific line n, using `tail +n /etc/passwd` where n is the line you want to start from.

### `sort`
**Purpose**: `sort` command, by default, puts the lines of a text in alphanumeric order. 
**Syntax**: 
```
sort /etc/passwd
```
**Additional Flags / Arguments**:
- To sort by numerical order, use the `-n` flag `sort -n /etc/passwd`
- To reverse the order, use `-r` flag `sort -r /etc/passwd`

### Changing your password and shell
- To change your password use `passwd` command
- To change your shell use `chsh` command

### Dot files
- Think of dot files as something similar to hidden files and directories
- Programs like `ls` doesn't show these files by default. For example, `ls` will only show these files when you use `-a` flag with it.

### environment and shell variables
- variables are something that a user defines to keep track of the text strings
- shell variables are the variables that are not passed to the sub-processes and are valid only for that shell session. If you quit the terminal, the value is lost
- For example, 
```
VAR="Hello"
echo $VAR // Spits Hello
bash -c 'echo $VAR' // doesn't output anything because it is not passed it to another sub-process
```
- enivronment variables are the variables that are passed to the sub-processes and are valid only for that shell session.
- For example,
```
export VAR="Hello"
echo $VAR // Spits Hello
bash -c 'echo $VAR' // Spits Hello
```
- `bash -c` is used to create a new bash session, run the command specified, and then quit. `-c` is called command-mode

### The command PATH
- PATH is a special environment variable that lists out all the directories that the shell searches when you type a command
- shell looks at the command in a sequence in the list of directories specified.
- It always returns the first directory if multiple matches are found.
- To add a directory to the list of the directories in path, you simply do, `export PATH=dir:$PATH`
- This will add the specified directory to the beginning of the already existing directories in the path
- To add the directory to the end of the already existing directories, you simply do `export PATH=$PATH:dir`
- You can close the terminal window and re-open it if you messed up the path variable. Until you add it to the .bashrc or .profile files, your specified path won't be persistent.

### Special characters
- Linux has certain special characters and you should have a basic understanding of these

| Character | Name(s)                  | Uses                                                                                                                 |
| --------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| *         | star, asterisk           | Regular expression, glob character                                                                                   |
| .         | dot                      | Current directory, file/hostname delimiter                                                                           |
| \|        | pipe                     | Command pipes                                                                                                        |
| !         | bang                     | Negation, command history                                                                                            |
| /         | forward slash            | Directory delimiter, search command                                                                                  |
| \         | backslash                | Literals, macros (never directories)                                                                                 |
| $         | dollar                   | Variables and end of the line                                                                                        |
| '         | tick, (single) quote     | Literal strings                                                                                                      |
| `         | backtick, backquote      | Command susbstitution                                                                                                |
| "         | double quote             | Semi-literal strings                                                                                                 |
| ^         | Caret                    | Negation, beginning of line                                                                                          |
| ~         | tilde, squiggle          | Negation, directory shortcut                                                                                         |
| #         | hash, sharp, pound       | Comments, preprocessor, substitutions                                                                                |
| []        | [square] brackets        | Ranges                                                                                                               |
| { }       | braces, (curly) brackets | Statement blocks, ranges                                                                                             |
| -         | underscore, under        | Cheap substitute for a space used when spaces aren't allowed or wanted, or when autocomplete algorithms get confused |

### Command-Line Editing
- You can move around the command line either by using your arrows or the shortcuts below. 
- You get the previous commands by hitting the up and down arrows

| Keystroke | Action                                            |
| --------- | ------------------------------------------------- |
| CTRL-B    | Move the cursor left                              |
| CTRL-F    | Move the cursor right                             |
| CTRL-P    | View the previous command (or move the cursor up) |
| CTRL-N    | View the next command (or move the cursor down)   |
| CTRL-A    | Move the cursor to the beginning of the line      |
| CTRL-E    | Move the cursor to the end of the line            |
| CTRL-W    | Erase the preceding word                          |
| CTRL-U    | Erase the cursor from the beginning of the line   |
| CTRL-K    | Erase the cursor from the end of the line         |
| CTRL-Y    | Paste erased text (for example, from CTRL-U)      |
### Getting online help (man pages)
- man pages are a great but not the easiest way to go through what a command does and the options and flags it offers
- If you don't know the command, you can search a keyword. For example, what a command does.
- To search for a man page with a specific keyword use `man -k keyword`. For example, `man -k sort`
- man pages have numbered sections
- When someone refers to a man page, they often put the section number. For example, ping(8)

| Section | Description                                                           |
| ------- | --------------------------------------------------------------------- |
| 1       | User commands                                                         |
| 2       | Kernel system calls                                                   |
| 3       | Higher-level Unix programming library documentation                   |
| 4       | Device interface and driver information                               |
| 5       | File Descriptions (system configuration files)                        |
| 6       | Games                                                                 |
| 7       | File formats, conventions, and encodings (ASCII, suffixes, and so on) |
| 8       | System commands and servers                                           |
- By default, man page finds the first page it finds
- You can refer a page number in your command to tell man to go to that specific section
- For example, to view section 5 for /etc/passwd file, you can insert the section number before the page name like so: `man 5 passwd`
- use `info` command as an alternative to man if you don't like man's interface
- If you want to use `info` but don't like the interface, pipe it to a pager like less `info passwd | less`
- Some packages include their documentation in */usr/share/doc* rather than man or info.

### Shell Input and Output
- Linux supports redirecting standard input of one command to a file
- To redirect the output to a file. You can do the below
```
command > file
```
- If the file exists, the file will be overwritten with the newly created file
- In order to append the output to a file, do the below
```
command >> file
```
- This will create a file if there isn't such file or if there is a file, it will append this output to the already existing file
- In order, to avoid overwriting a file, you can use `set -C` which will avoid file clobbering
- Linux also supports redirecting the standard output of one command to the standard input of another command
- Use the `|` pipe character to do this
- For example,
```
head /proc/cpuinfo | tr a-z A-Z
```
### Standard Error
- Even though we redirect standard output you might still find some output that prints to the terminal occasionally. This is standard error (stderr)
- When you redirect a standard output to a file using the `>` or `>>` redirection, stderr won't be appended or sent to the file
- In order, to send the stderr to a file, you can do the below
```
ls /ffffff > f 2> e
```
- In Linux number 2 specifies the __stream ID__ that the shell modifies. 1 is standard output and 2 is standard error
- Additionally, you can send both stderr and stdout to the same place using `>&` notation. You can do the below
```
ls /fffff > f 2>&1
```
### Standard Input Redirection
- You can also send a file to a standard input of another program using `<` operator
- For example,
```
head < /proc/cpuinfo
```
- Most of the Linux commands doesn't require you to do this. For example, above command can be easily re-written as `head /cpu/procinfo`

### Understanding Error Messages
- Linux errors explain exactly what went wrong
- For example, consider the below
```
ls /ffffjfd
ls: cannot access /ffffjfd: No such file or directory
```
- what is the command name: ls
- what is the error message: cannot access a directory called so and so
- why didn't it work: Because there is no such directory

- So, the above command didn't work because a program named ls tried to access a directory called /ffffjfd because it doesn't exist
- Every program spits out such information, in a huge list of other outputs. Always try to find an error message like this.
- Unlike error messages, there are something called warnings, these often look like error messges, but contain a word warning. Your program will run even if you have warnings.

### Common Errors
- Below are the common errors you will encounter in a Unix system.

    #### No such file or directory
    - There is no such file or directory that you're trying to access
    - This error is also known as ENOENT, "Error no Entity". This error is a result of open() system call
    #### File exists
    - When you tried to create a file that already exists.
    #### Not a directory, is a directory
    - Occurs when you try to use a file as a directory or a directory as a file. For example
    ```
    touch a 
    touch a/b 
    touch: a/b: Not a directory
    ```
    #### No space left on device
    - You're out of disk space
    #### Permission denied
    - You don't have enough permissions to write or read the directory or a file that you're trying to access
    - This also occurs when you're trying to execute a file that is not made an executable 
    #### Operation not permitted
    - If you don't own the process and try to kill it 
    #### Segmentation fault, bus error
    - A __segmentation fault__ occurs when you run a faulty program that is trying to access the memory that it was not allowed to touch, or trying to access in a way that it shouldn't have, and the operation system killed it. 

### Listing and Manipulating Processes
- Process is just another running program
- `ps` to list all the running processes
- `PID` - process ID
- `TTY` - the terminal device where the process is running
- `STAT` - the status of the process. S is sleeping and R is running. `man ps 1` for more
- `TIME` - the CPU time that the process took in minutes. This is different from the amount of time it took since it started.
- `COMMAND` - the command that is used to run the process. This can be changed when the process changes its value or if shell performs glob or expansion.
- After the process is terminated, kernel might use the same PID for another process but PID for all the running processes is unique

#### `ps` command options
- `ps x` show all of your running processes
- `ps ax` show all processes on the system, not only the ones you own
- `ps u` include more detailed information on process
- `ps w` show full command names, not just what fits on the line
- you can always combine options above and many others just like the other commands
- `$$` refers to the current shell. Use `ps u $$` for more information on the current running shell

#### Process Termination
- To kill a process use `kill PID`
- Default signal used with kill is `SIGTERM` meaning terminate
- To use another signal, specify the flag like so `kill -STOP PID`. This stops / freezes the process rather than terminating it
- A stopped process will still be in memory. To continue use `SIGCONT` like so `kill -CONT PID`
- Kernel will expect the process to clean up themselves upon receiving signals. 
- If a process is persistent use `SIGKILL` which is a brutal way of killing a process.
- Kernel terminates the process and removes it from the memory.
- Only do this if you know what you're doing.
- When you use `CTRL-C` to terminate a process, you're using `SIGINT` or interrupt.
- You can also use numbers with the command `kill` which is equal to using the full signal name. For example, instead of `kill -KILL`, you can use `kill -9`. 
- Use `kill -l` to see full list.

### Job Control
- shell sends TSTP (similar to STOP) and CONT signals to programs by using various keystrokes and commands
- Press `CTRL-Z` to send a TSTP signal to a process
- Use `jobs` to see the list of running jobs
- Use `fg` to bring the process back to the foreground
- Use `bg` to send the process to the background
- `screen` and `tmux` utilities are better than the actual jobcontrol

### Background processes
- When you want the prompt back even after running a command, you can use the `&` symbol just after the command
- For example, `firefox &`
- Shell prints `PID` of the process and returns you the prompt
- Process can continue even after user logsout
- If the process finishes before logging out it is usually notified to the user
- Use `nohup` which is no hangup when you want a process to run on a remote machine even after loggingout

### File modes and permissions
- Every unix file determine whether you can read, write, or run the file.
- You can see this with `ls -l`
```bash
-rw-r--r-- 1 juser somegroup 7041 Mar 26 19:34 hello.txt
```
- `-rw-r--r--` represents file's mode and some extra information
- This can be divided into four parts
- First part is `rw` for user permissions
- Second part `r--` is for group permissions
- Third part `r--` is for other permissions
- The first part `-` is for filetype. `-` means, it is a regular file. If it is a `d`, then it is a directory
- So, in a sequence, these are `ugo` permissions
- `r` means the file is readable
- `w` means the file is writable
- `x` means the file is executable
- `-` means nothing, meaning the permission for that slot in the set has not been granted
- Every user in the group can take advantage of the second set of permissions. 
- First set is for user, second set is for group, third set is for others.
- You can use the `groups` command to see which group you're in
- The permissions for others are sometimes called _world_ permissions
- Every set in the file permissions is called a _permission bit_. For example, the `r` can be referred to _the read bits_
- Some executables have _s_ in the executable bit than _x_. In this case, the file when run, runs as the actual owner instead of the user that run the file through a thing called _setuid_ which actually gets the uid of the owner when run. For example, files like `/etc/passwd` do this to get the root access 

---

## ‚ùì Flashcards
START
Basic
Front:  
Back:  
END

---

## üíª Commands Practiced
- Command: `____`
  - What it does:  
  - Example output:  

---

## üîÑ Review Log
- [ ] Day 2: {{date+1d}}
- [ ] Day 4: {{date+3d}}
- [ ] Day 8: {{date+7d}}
- [ ] Day 15: {{date+14d}}
